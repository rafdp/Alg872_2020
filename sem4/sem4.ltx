\documentclass{article}

\usepackage{graphicx} 
\usepackage{amsmath} 
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,footskip=1cm]{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{eufrak}
\usepackage{amssymb}
\usepackage{esvect}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan
}
\newcommand{\fp}{\mathfrak{F}_p}
\newcommand{\fs}{\mathfrak{F}_s}
\newcommand{\np}{\mathcal{NP}}
\newcommand{\p}{\mathcal{P}}
\newcommand{\sym}[1]{\raisebox{\depth}{#1}$}
\newcommand*{\ou}[2]{\sym{\overset{\text{\large ${#1}$}}{#2}}}

\setlength\parindent{0pt} 

\title{Семинары 4-5. \\ $\mathcal{NP}$-полнота, пространственная сложность, $\mathbf{L}$ и $\mathbf{NL}$}

\author{Составил Р. Делла Пиетра} 
\date{(7,14).2.20}


\begin{document}

\maketitle
\section{$EXACTCOVER$}
Покажем, что задача точного покрытия множества $\np$ полная.\\
Формулировка такая: на вход подаётся число $n$ семейство множеств $S \subset 2^{\overline{1 ,n}}$, нужно определить, можно ли из $S$ выбрать дизъюнктное подсемейство, покрывающее $\overline{1 ,n}$. \\
Сведём $3SAT$ к этой задаче. \\
Для каждой переменной, используемой в булевой формуле, <<бронируем>> $3$ числа: $p, p_0, p_1$. Для каждого дизъюнкта $4$ числа: $C, C_1, C_2, C_3$.
С каждой переменной добавляем множества $\{p, p_0\}$ и $\{p, p_1\}$ в семейство, с каждым дизъюнктом добавляем $\{C\}, \{C, C_i\}, \{C, C_i, C_j\} \;\forall i\neq j$.
Также добавляем множества такого вида: для каждой переменной делаем множества $\{p_1, \dotsc\}$ и $\{p_0, \dotsc\}$, где в первом троеточие~---~$C_i$, если в дизъюнкте $C$ переменная на $i$-м месте, а во втором $C_j$ если отрицание переменной на $j$-м месте.\\
Пример: $\varphi = (x \vee y) \and (\overline {y} \vee z \vee x) \implies A = (x \vee y), B = (\overline {y} \vee z).$\\
Добавляем числа $x, x_0, x_1, y, y_0, y_1, z, z_0, z_1, A, A_1, A_2, A_3, B, B_1, B_2, B_3$, то есть $n = 17$, \\
и $S = \{\{x, x_0\}, \{x, x_1\}, \textit{то же самое для $y$ и $z$}, \\
\{A\}, \{A, A_1\}, \{A, A_2\}, \{A, A_3\}, \{A, A_1, A_2\}, \{A, A_2, A_3\}, \{A, A_3, A_1\}, \textit{то же самое для $B$}, \\
\{x_1, A_1, B_3\}, \{y_1, A_2\}, \{y_0, B_1\}, \{z_1, B_2\}\}$.\\
Покажем, что сводимость корректна.\\
Если в выполняющем наборе $p$ принимает значение $i$, выбираем $\{p, p_{1-i}\}$ и $\{p_i, \dotsc\}$. После выбора всех таких множеств для всех переменных, выбираем остатки для дизъюнктов. \\
На том же примере: выполняющий набор $x = 1, y = 0, z = 1$. \\
$\{x, x_0\}, \{y, y_1\}, \{z, z_0\}, \{x_1, A_1, B_3\}, \{y_0, B_1\}, \{z_1, B_2\}, \{A, A_2, A_3\}, \{B\}$ дизъюнктно покрывают всё $S$. \\
В другую сторону: есть дизъюнктное покрытие, значит можно составить выполняющий набор. Это ясно интуитивно: из множеств вида $\{p, p_i\}$ для каждой переменной будет выбрано одно, которое как раз будет говорить о значении переменной. Из множеств вида $\{p_i, \dotsc\}$ тоже будут выбраны по одному для каждой переменной, показывающему, какие дизъюнкты выполняются. Остаток будет состоять из множеств вида $\{A\}, \{A, A_i\}, \{A, A_i, A_j\}$, где $i, j$~---~места в дизъюнкте, указывающие на невыполненные переменные. При этом в $S$ нет множеств вида $\{A, A_1, A_2, A_3\}$, поэтому для каждого дизъюнкта хотя бы одна переменная будет выполняться, то есть формула выполнима. \\
Таким образом, $3SAT\leqslant_pEXACTCOVER$. По теореме Кука-Левина $3SAT \in \np c$, \\
поэтому $EXACTCOVER\in \np h$. \\
Тривиально проверяется, что $EXACTCOVER \in \np$, поэтому $EXACTCOVER \in \np c$.
\newpage
\section{Полиномиальная иерархия}
Введём группу классов, более сложных, чем $\np$ и $co\np$, но всё ещё требующих полиномиальные по времени вычисления.
\[\Sigma_0 = \p\quad \Sigma_1 = \np\quad \Sigma_k = \{L|x\in L \iff \exists y_1 \forall y_2 \dotsc (\forall, \exists) y_k: R(x, y_1, \dotsc, y_k) = 1 : R \in \fp(|x|), y_i < poly(|x|)\}\]
\[\Pi_0 = \p\quad \Pi_1 = co\np\quad \Pi_k = \{L|x\in L \iff \forall y_1 \exists y_2 \dotsc (\forall, \exists) y_k: R(x, y_1, \dotsc, y_k) = 1 : R \in \fp(|x|), y_i < poly(|x|)\}\]
\[\mathcal{PH} = \bigcup \Sigma_k = \bigcup \Pi_k\]
\subsection{Примеры задач}
\subsubsection{SAT}
Для $\Sigma_k$ есть обобщение задачи $SAT$, так называемая $\Sigma_k SAT$: язык булевых формул от $k$ групп переменных: $\exists \vv{y_1} \; \forall\vv{y_2} \dotsc \varphi(\vv{y_1}, \dotsc, \vv{y_k}) = 1$. Эта задача $\Sigma_k$ полная.
\subsubsection{Графы}
Задача клики также обобщается: язык $\{(G, k)\}$, где $G$~---~описание графа, а $k$~---~максимальный размер клики в графе, лежит в $\Sigma_2$. 
\subsection{Схема вложений}
В каждом из предикатов можно игнорировать крайние справа и слева переменные, поэтому легко видеть, что $\Sigma_k \cup\Pi_k \in \Sigma_{k+1}$, $\Sigma_k \cup \Pi_k \in \Pi_{k+1}$, но утверждение $\Sigma_{k+1} = \Pi_{k+1}$ нетривиально и может быть неверно. 

\subsection{Схлопывания}
Что происходит, если $\p = \np$? Вся полиномиальная иерархия схлопывается в $\p$. Также могут происходить другие сценарии: если $\exists k: \Sigma_k = \Sigma_{k+1}$ или $\Sigma_k = \Pi_k$, то полиномиальная иерархия коллапсирует до этого уровня.


\section{Пространственная сложность}
\[ DSPACE(s(n)) = \{L|\exists \textit{детерминированная МТ, разрешающая $L$, затрагивая } O(s(n)) \textit{ ячеек ленты}\} \]
\[ NSPACE(s(n)) = \{L|\exists \textit{недетерминированная МТ, разрешающая $L$, затрагивая } O(s(n)) \textit{ ячеек ленты}\} \]
\[ \fs(n) = \{\textit{функции, вычислимые на } poly(n) \textit{ ячейках ленты}\}\]
\[ \p SPACE= \mathop{\bigcup}\limits_{c=1}^{\infty} DSPACE(n^c) =  \{L\;|\;\exists \chi_L(x) \in \fs(|x|), \; \chi_L\textit{~---~характеристическая функция}\} \]
\[ \np SPACE = \mathop{\bigcup}\limits_{c=1}^{\infty} NSPACE(n^c) \]
Во всех вопросах, касающихся пространственной сложности, измеряется дополнительная память, то есть память, которая требуется разрешающему алгоритму, не учитывая сам вход.
\subsection{Теорема Сэвича}
$DSPACE(s(n)) \subseteq NSPACE(s(n)) \subseteq DSPACE(s^2(n))$, если $s(n)$ растёт быстрее логарифма.\\
Из теоремы следует, что $\p SPACE = \np SPACE$
\newpage

\subsection{Примеры задач}
\subsubsection{$SPACE\;TM\;SAT$}
$SPACE\;TM\;SAT = \{(M, x, 1^s) | M(x) = 1 \text{ и вычисление $M(x)$ требует $s$ ячеек}\}$~---~$\p SPACE$-полная задача.\subsubsection{$True \ Quantified \ Boolean\ Formulae$}
$TQBF = \{\varphi(x_1, x_2, \dotsc, x_k) | \forall x_1 \exists x_2 \dotsc (\forall, \exists) x_k: \varphi(x_1, \dotsc x_k) = 1\}$.
Покажем по индукции, что она лежит в $\p SPACE$. \\
Для того, чтобы определить значение формулы без кванторов, требуется логарифмическая память (об этом подробнее на следующем семинаре). \\
Для формулы из одной переменной делаем такие действия: если попался квантор всеобщности, подставляем по очереди $0$ и $1$, вычисляем формулу, если что-то оказалось $0$ прерываем с ответом $0$. Если квантор существования, делаем то же самое, но прерываем, если попался $1$. \\
Легко видеть, что здесь нужна полиномиальная память от длины формулы, т.~к. для ответов нужна константа, а для вычислений логарифм. \\
База индукции есть, далее пусть мы умеем решать задачу для любого количества \\
переменных $k < n$ с любыми кванторами.
Для формулы с $n$ переменными поступим таким же образом: вместо первой переменной подставляем фиксированное значение $0$ или $1$. Новая формула будет булевой формулой от $n-1$ оставшихся переменных, то есть её можно проверить на полиномиальной памяти по предположению индукции. Таким образом, мы можем вычислить ответ для формулы из $n$ переменных, и пройтись по $0$ и $1$ и определить выполнение квантора. За новый шаг индукции мы снова использовали константу памяти и логарифм для вычислений. \\
Всего переменных не больше, чем $|\varphi|$, глубина рекурсии не больше длины входа, поэтому используемая память линейна.
\section{$\mathbf{L}, \mathbf{NL}$}
\[ \mathbf{L}= DSPACE(\log n) \]
\[ \mathbf{NL}= NSPACE(\log n) \]
\subsection{Примеры задач из $\mathbf{L}$}
\subsubsection{LE}
$LE = \{(x, y) \ |\ x\leqslant y\}$. Для того, чтобы сравнить два числа, нужно проверить их длины и, если они одинаковые, сравнить посимвольно. \\
Для проверки длин потребуются два счётчика, каждый из которых занимает $\max (\log \log x, \log \log y)$ памяти. Двойной логарифм т.~к. длина входа задачи $\log x + \log y$.
Посимвольное сравнение требует $1$ бит памяти.
\subsubsection{ADD}
$ADD = \{(x, y, z) \ |\ x+y=z\}$. Будем вычислять сумму $x$ и $y$ побитово и сравнивать с соответствующим битом $z$. Для этого понадобится $1$ бит~---~результат сложения, $1$ бит для переносов и $\log \log z$ бит для счётчика текущего сравниваемого бита.
\subsubsection{MUL}
$MUL = \{(x, y, z) \ |\ xy=z\}$. Также будем вычислять побитово, но нам понадобится большее количество счётчиков, но идея вычислять ответ побитово и сравнивать с $z$ тоже работает.

\subsection{Сертификатное определение $\mathbf{NL}$}
$L \in \mathbf{NL} \iff \exists V(x, y): x \in L \iff \exists y: V(x, y) = 1$ с данными ограничениями: \\
доступ к $x$ не ограничен, $y$ можно читать только один раз слева направо, вычисления должны требовать логарифмической памяти.

\subsection{$LOGSPACE$ сводимость}
$A \leqslant_l B \iff \exists f$ требует для вычислений логарифмическую дополнительную память от длины входа, и $x \in A \iff f(x) \in B$.\\ 
Композиция $LOGSPACE$ функций тоже $LOGSPACE$ функция, поэтому работают аналогичные свойства, как и для $m$ и $p$ сводимостей: рефлексивность и транзитивность. Кроме того, если $B \in \mathbf{(N)L}$, то $A$ лежит в том же классе.
\subsection{$PATH$}
Покажем, что задача $PATH = \{(G, s, t) \ | $ в графе $G$ есть путь из вершины $s$ в вершину $t \}$ NL-полная относительно $l$-сводимости.\\
Для начала покажем, что он лежит в $NL$: сертификатом будет последовательность вершин, а верификатор пусть проходит по ней и проверяет, что соседние вершины в пути связаны ребром. Для этого из дополнительной памяти понадобится номер текущей вершины, то есть $\log n$ при входе длины $n^2 + 2\log n$.\\
Покажем полноту: пусть есть некоторая задача из $\mathbf{NL}$. Это значит, что для этой задачи есть недетерминированная МТ, разрешающая её, требуя логарифмическую дополнительную память. По определению недетерминированная МТ принимает слово, если существует путь в графе конфигураций от начального состояния к принимающему. Идея понятна, осталось доказать, что такая сводимость корректна по памяти.
\end{document}

